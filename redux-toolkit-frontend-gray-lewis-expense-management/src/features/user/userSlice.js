import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

import fetch from 'isomorphic-fetch'

const baseUrl = 'http://localhost:5000'; //normally better to create a API collection layer, but it's fine for simplicity

const initialState = {
  jwt: undefined,
  username: undefined,
}

export const loginAsync = createAsyncThunk(
  'user/loginAsync',
  async (values) => {
    const {email, password} = values;
    const response = await fetch(`${baseUrl}/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        email,
        password
      })
    })
    // The value we return becomes the `fulfilled` action payload
    const parsedResponse = await response.json()
    localStorage.setItem('token', parsedResponse) //generally side effect things, e.g like localStorage interaction, put in thunk, in in reducer, reducer is just pure function state machine
    return parsedResponse // The value we return becomes the `fulfilled` action payload, same as Promise.response
  }
);

export const registerAsync = createAsyncThunk(
  'user/registerAsync',
  async (values) => {
    const {email, password, birthday} = values;
    const response = await fetch(`${baseUrl}/register`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        email,
        password,
        birthday
      })
    })
    // The value we return becomes the `fulfilled` action payload
    const parsedResponse = await response.json()
    return parsedResponse
  }
);

export const fetchExpenses = createAsyncThunk(
  'user/fetchExpenses',
  async (jwt) => {
    const response = await fetch(`${baseUrl}/expenseBook`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
    })
    const parsedResponse = await response.json()
    return parsedResponse
  }
)

export const saveExpenses = createAsyncThunk(
  'user/saveExpenses',
  async (expenses) => {
    const response = await fetch(`${baseUrl}/save`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: JSON.stringify(
        expenses
      )
    })
    const parsedResponse = await response.json()
    return parsedResponse
  }
)

export const deleteExpense = createAsyncThunk(
  'user/deleteExpense',
  async (_id) => {
    const response = await fetch(`${baseUrl}/delete`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: JSON.stringify({
        _id
      })
    })
    const parsedResponse = await response.json()
    return parsedResponse
  }
)

export const userSlice = createSlice({
  name: 'counter',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Use the PayloadAction type to declare the contents of `action.payload`
    login: (state, action) => {
      state.jwt = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(loginAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(loginAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.jwt = action.payload;
      })
      .addCase(saveExpenses.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(saveExpenses.fulfilled, (state, action) => {
        state.status = 'idle';
        state.savedAt = Date.now();
      });
  },
});


export default userSlice.reducer;